<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Sky Odyssey</title>

  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" href="skyico.png" />
  <meta name="theme-color" content="#000510" />

  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

  <style>
    html, body {
      width:100%; height:100%;
      margin:0; background:#000; overflow:hidden;
      font-family: "Segoe UI", sans-serif;
      touch-action: manipulation;
    }

    /* Caméra réelle en fond */
    #cameraFeed {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 0;
      background: #000;
      transform: scaleX(-1); /* miroir léger type selfie — retire si tu veux */
    }

    /* A-Frame au-dessus, avec fond transparent */
    a-scene {
      position: fixed !important;
      inset: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 1 !important;
      background: transparent !important;
    }
    canvas { width:100% !important; height:100% !important; }

    /* UI */
    #ui {
      position: fixed; top: 0; left: 0; width: 100%;
      z-index: 9999;
      padding: 16px; box-sizing: border-box;
      background: linear-gradient(to bottom, rgba(0,5,15,0.80), transparent);
      color: #00ffcc;
      pointer-events: auto;
    }
    #title { font-weight:800; letter-spacing:2px; font-size:20px; }
    #gps { font-family: monospace; font-size: 12px; color:#cfe9ff; opacity:0.95; margin-top: 6px; }

    #controls { display:flex; gap:12px; flex-wrap:wrap; margin-top: 12px; }
    select, button {
      background:#001a2b; color:#00ffcc; border:1px solid #00ffcc;
      padding:10px 12px; border-radius:10px; font-size:14px; outline:none;
    }
    button:active { transform: scale(0.98); }

    #guideBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(0,255,204,0.35);
      background: rgba(0,0,0,0.35);
      color:#fff;
      font-family: monospace;
      font-size: 13px;
      max-width: 96vw;
    }

    /* Crosshair */
    #cross {
      position: fixed; left:50%; top:50%;
      transform: translate(-50%, -50%);
      z-index: 9998; pointer-events:none;
      width:18px; height:18px; opacity:0.95;
    }
    #cross:before, #cross:after {
      content:""; position:absolute; background: rgba(0,255,204,0.9);
      box-shadow: 0 0 10px rgba(0,255,204,0.25);
    }
    #cross:before { left:50%; top:0; width:2px; height:18px; transform:translateX(-50%); }
    #cross:after  { top:50%; left:0; width:18px; height:2px; transform:translateY(-50%); }

    /* Big arrow */
    #arrowWrap{
      position: fixed; left:50%; top:58%;
      transform: translate(-50%,-50%);
      z-index: 9998; pointer-events:none;
      width: 90px; height: 90px;
      display:flex; align-items:center; justify-content:center;
      opacity: 0.95;
    }
    #arrow{
      width:0; height:0;
      border-left:18px solid transparent;
      border-right:18px solid transparent;
      border-bottom:36px solid rgba(255,210,74,0.95);
      filter: drop-shadow(0 0 10px rgba(255,210,74,0.25));
      transform: rotate(0deg);
      transition: transform 0.08s linear, opacity 0.2s ease;
    }
    #arrow.hidden { opacity:0; }

    /* Bottom status */
    #status{
      position: fixed; bottom: 18px; left: 50%;
      transform: translateX(-50%);
      z-index: 9999; pointer-events:none;
      background: rgba(0, 20, 40, 0.70);
      border:1px solid rgba(0,255,204,0.45);
      padding: 10px 14px;
      border-radius: 14px;
      text-align:center;
      min-width: 280px;
      color:#fff;
      box-shadow: 0 0 18px rgba(0,255,204,0.15);
      display:none;
    }
    #status .name{ letter-spacing:2px; font-size:12px; opacity:0.9; text-transform: uppercase; }
    #status .align{ font-size:22px; color:#00ffcc; font-weight:800; margin:6px 0 0 0; }
    #status .hint{ font-size:12px; color:#cfe9ff; opacity:0.95; margin-top:2px; }

    /* Petit bouton caméra */
    #camBtnRow { display:flex; gap:12px; flex-wrap:wrap; margin-top: 10px; }
    #camStatus { font-family: monospace; font-size: 12px; color:#fff; opacity:0.95; }
  </style>
</head>

<body>
  <!-- Caméra réelle -->
  <video id="cameraFeed" autoplay playsinline muted></video>

  <div id="ui">
    <div id="title">SKY ODYSSEY</div>
    <div id="gps">GPS…</div>

    <div id="guideBox">
      1) Appuie “Activer caméra”. 2) Choisis un objet. 3) Suis la flèche jusqu’à “✅ centré”.
    </div>

    <div id="camBtnRow">
      <button id="btnCam">Activer caméra</button>
      <div id="camStatus">Caméra: OFF</div>
    </div>

    <div id="controls">
      <select id="target">
        <option value="">-- Sélectionner Cible --</option>
        <optgroup label="Système Solaire" id="planets"></optgroup>
        <optgroup label="Étoiles" id="stars"></optgroup>
      </select>
      <button id="recenter">Recentrer</button>
    </div>
  </div>

  <div id="cross"></div>
  <div id="arrowWrap"><div id="arrow" class="hidden"></div></div>

  <div id="status">
    <div class="name" id="stName">---</div>
    <div class="align" id="stAlign">--%</div>
    <div class="hint" id="stHint">---</div>
  </div>

  <a-scene embedded vr-mode-ui="enabled:false" renderer="antialias:true; precision:mediump; alpha:true">
    <a-entity id="rig">
      <a-entity id="cam"
        camera="near:0.1; far:4000"
        position="0 1.6 0"
        look-controls="enabled:true; magicWindowTrackingEnabled:true; touchEnabled:true"
        wasd-controls="enabled:false">
      </a-entity>
    </a-entity>

    <!-- ciel transparent (on voit la vidéo derrière) -->
    <a-sky color="#000000" material="opacity:0; transparent:true"></a-sky>
    <a-light type="ambient" intensity="1.0"></a-light>

    <!-- Marker unique (la cible) -->
    <a-entity id="targetMarker" visible="false">
      <a-sphere radius="0.35"
        material="color:#ffd24a; emissive:#ffd24a; emissiveIntensity:1.4; opacity:1; transparent:true"></a-sphere>
      <a-text id="markerLabel" value="" position="0 0.8 0" align="center" width="6" color="#ffffff"></a-text>
    </a-entity>
  </a-scene>

  <script>
    // ----------------------------
    // Data
    // ----------------------------
    const starData = [
      { name: "Sirius", ra: 6.75, dec: -16.71, dist: 8.6 },
      { name: "Vega", ra: 18.61, dec: 38.78, dist: 25.0 },
      { name: "Betelgeuse", ra: 5.92, dec: 7.41, dist: 642.5 },
      { name: "Polaris", ra: 2.53, dec: 89.26, dist: 431.4 },
      { name: "Alpha Centauri", ra: 14.66, dec: -60.83, dist: 4.37 },
      { name: "Rigel", ra: 5.24, dec: -8.20, dist: 863.0 }
    ];
    const planets = ["Sun", "Moon", "Mars", "Jupiter", "Saturn", "Venus"];

    let userCoords = null;
    let selected = null;
    let targetDirWorld = null; // THREE.Vector3 unit direction in world
    let targetAlt = null;

    const gpsEl = document.getElementById("gps");
    const guideEl = document.getElementById("guideBox");
    const statusEl = document.getElementById("status");
    const stName = document.getElementById("stName");
    const stAlign = document.getElementById("stAlign");
    const stHint = document.getElementById("stHint");
    const arrow = document.getElementById("arrow");

    const videoEl = document.getElementById("cameraFeed");
    const camBtn = document.getElementById("btnCam");
    const camStatus = document.getElementById("camStatus");

    const marker = document.getElementById("targetMarker");
    const markerLabel = document.getElementById("markerLabel");

    // Populate lists
    const pList = document.getElementById("planets");
    const sList = document.getElementById("stars");
    planets.forEach(p => pList.innerHTML += `<option value="${p}">${p}</option>`);
    starData.forEach(s => sList.innerHTML += `<option value="${s.name}">${s.name}</option>`);

    // Service worker (optional)
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("sw.js").catch(()=>{});
      });
    }

    // GPS
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        userCoords = pos.coords;
        gpsEl.textContent = `LAT: ${userCoords.latitude.toFixed(4)} | LON: ${userCoords.longitude.toFixed(4)}`;
      },
      () => {
        gpsEl.textContent = "GPS refusé / erreur";
        guideEl.textContent = "Autorise la localisation pour calculer le ciel.";
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 5000 }
    );

    // Camera activation (must be user gesture)
    camBtn.addEventListener("click", async () => {
      try {
        camStatus.textContent = "Caméra: demande…";
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false
        });
        videoEl.srcObject = stream;
        camStatus.textContent = "Caméra: ON";
        guideEl.textContent = "Caméra OK. Choisis un objet puis suis la flèche.";
        // enlever miroir (arrière) si tu préfères une vue non inversée
        videoEl.style.transform = "none";
      } catch (e) {
        console.log(e);
        camStatus.textContent = "Caméra: REFUSÉE";
        guideEl.textContent = "Refus caméra. Vérifie HTTPS + permissions.";
      }
    });

    // UI selection
    document.getElementById("target").addEventListener("change", (e) => {
      selected = e.target.value || null;
      updateTargetFromSelection();
    });

    // Recenter
    document.getElementById("recenter").addEventListener("click", () => {
      const camEl = document.getElementById("cam");
      camEl.setAttribute("rotation", "0 0 0");
      const lc = camEl.components && camEl.components["look-controls"];
      if (lc) {
        try {
          if (lc.yawObject) lc.yawObject.rotation.y = 0;
          if (lc.pitchObject) lc.pitchObject.rotation.x = 0;
          if (typeof lc.pause === "function") lc.pause();
          if (typeof lc.play === "function") lc.play();
        } catch {}
      }
      guideEl.textContent = selected ? "Recentré. Suis la flèche." : "Recentré. Choisis un objet.";
    });

    // Refresh target periodically (the sky moves)
    setInterval(updateTargetFromSelection, 1200);

    function azAltToUnitVector(azDeg, altDeg) {
      // Convention cohérente avec ta sphère (az+180)
      const az = (azDeg + 180) * Math.PI / 180;
      const alt = altDeg * Math.PI / 180;
      const y = Math.sin(alt);
      const r = Math.cos(alt);
      const x = r * Math.cos(az);
      const z = r * Math.sin(az);
      return new AFRAME.THREE.Vector3(x, y, z).normalize();
    }

    function updateTargetFromSelection() {
      if (!userCoords || !selected) {
        targetDirWorld = null;
        marker.setAttribute("visible", "false");
        statusEl.style.display = "none";
        arrow.classList.add("hidden");
        return;
      }

      const obs = new Astronomy.Observer(userCoords.latitude, userCoords.longitude, 0);
      const now = new Date();

      try {
        if (planets.includes(selected)) {
          const eq = Astronomy.Equator(selected, now, obs, true, true);
          const horiz = Astronomy.Horizon(now, obs, eq.ra, eq.dec, "refray");
          targetAlt = horiz.altitude;
          targetDirWorld = azAltToUnitVector(horiz.azimuth, horiz.altitude);

          statusEl.style.display = "block";
          stName.textContent = selected;
          markerLabel.setAttribute("value", selected.toUpperCase());
          marker.setAttribute("visible", "true");
          return;
        }

        const star = starData.find(s => s.name === selected);
        if (star) {
          const horiz = Astronomy.Horizon(now, obs, star.ra, star.dec, "refray");
          targetAlt = horiz.altitude;
          targetDirWorld = azAltToUnitVector(horiz.azimuth, horiz.altitude);

          statusEl.style.display = "block";
          stName.textContent = selected;
          markerLabel.setAttribute("value", selected.toUpperCase());
          marker.setAttribute("visible", "true");
          return;
        }
      } catch (e) {
        console.log(e);
      }

      targetDirWorld = null;
      marker.setAttribute("visible", "false");
      statusEl.style.display = "none";
      arrow.classList.add("hidden");
    }

    const camEl = document.getElementById("cam");

    function loop() {
      requestAnimationFrame(loop);
      if (!targetDirWorld || !camEl || !camEl.object3D) return;

      // Camera forward
      const camForward = new AFRAME.THREE.Vector3();
      camEl.object3D.getWorldDirection(camForward);
      camForward.normalize();

      // Angular error
      const dot = Math.max(-1, Math.min(1, camForward.dot(targetDirWorld)));
      const angleRad = Math.acos(dot);
      const angleDeg = angleRad * 180 / Math.PI;

      // Alignment %
      const align = Math.max(0, Math.min(100, Math.round(100 - (angleDeg / 60) * 100)));
      stAlign.textContent = `${align}%`;

      const horizonHint = (targetAlt < 0)
        ? "⚠️ Sous l’horizon (virtuel)"
        : "Au-dessus de l’horizon";
      stHint.textContent = `Écart: ${angleDeg.toFixed(1)}° • ${horizonHint}`;

      // Target direction in camera local space → arrow
      const camQuat = new AFRAME.THREE.Quaternion();
      camEl.object3D.getWorldQuaternion(camQuat);
      const invCam = camQuat.clone().invert();
      const rel = targetDirWorld.clone().applyQuaternion(invCam);

      const dx = rel.x; // right
      const dy = rel.y; // up

      if (angleDeg < 6) {
        arrow.classList.add("hidden");
        guideEl.textContent = `✅ ${selected} centré !`;
      } else {
        arrow.classList.remove("hidden");
        guideEl.textContent = `Suis la flèche pour viser ${selected}.`;
        const rot = Math.atan2(dx, dy) * 180 / Math.PI;
        arrow.style.transform = `rotate(${rot}deg)`;
      }

      // Place marker in 3D space in correct direction
      const radius = 12;
      const pos = targetDirWorld.clone().multiplyScalar(radius);
      marker.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);

      // Make it bigger when close
      const s = (angleDeg < 12) ? 1.5 : 1.0;
      marker.setAttribute("scale", `${s} ${s} ${s}`);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
